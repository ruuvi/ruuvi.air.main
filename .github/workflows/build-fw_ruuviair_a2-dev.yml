name: Build firmware (dev) for RuuviAir-A2

on:
  push:
    branches: [ master ]
    tags: [ '*' ]
  pull_request:
    branches: [ '*' ]
    types: [ opened, synchronize, reopened ]

env:
  NCS_VERSION: v2.9.2
  PROJECT_DIR: ruuvi.air
  SCRIPT_NAME: build_ruuviair_a2_release-dev

jobs:
  build:
    name: Build firmware (dev) for RuuviAir-A2
    environment: dev
    runs-on: ubuntu-24.04
    permissions:
      contents: write  # required to create GitHub Releases and upload assets

    strategy:
      matrix:
        image_tag: [ latest ]

    defaults:
      run:
        shell: bash

    steps:
      - name: Set image ref
        id: img
        run: |
          echo "IMAGE_REF=ghcr.io/${{ github.repository_owner }}/ruuvi-air-ci:${{ matrix.image_tag }}" >> $GITHUB_OUTPUT

      - name: Make image-ref hash
        id: img_hash
        run: |
          echo "IMAGE_REF_HASH=$(echo -n '${{ steps.img.outputs.IMAGE_REF }}' | sha256sum | cut -c1-12)" >> $GITHUB_OUTPUT

      # Log in to GHCR. This can be removed if the image is public.
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load Docker image
        run: |
          set -xeuo pipefail
          echo "Pulling image ${{ steps.img.outputs.IMAGE_REF }} ..."
          docker pull "${{ steps.img.outputs.IMAGE_REF }}"

      - name: Prepare cache directories
        run: |
          pwd
          echo HOME: ~
          echo HOME: $HOME
          mkdir -p ~/.nrfutil
          mkdir -p ~/bin
          mkdir -p ~/ncs
          mkdir -p ~/ncs/toolchains
          mkdir -p ~/ncs/${NCS_VERSION}

      - name: Restore cached 'nrfutil Toolchain Manager'
        id: cache-nrfutil-tcm
        uses: actions/cache/restore@v4
        with:
          path: ~/.nrfutil
          key: nrfutil-tcm-${{ env.NCS_VERSION }}-v4

      - name: Restore cached 'nRF Connect toolchains'
        id: cache-ncs-toolchains
        uses: actions/cache/restore@v4
        with:
          path: ~/ncs/toolchains
          key: ncs-toolchains-${{ env.NCS_VERSION }}-v4

      - name: Restore cached 'nRF Connect SDK ${{ env.NCS_VERSION }}'
        id: cache-ncs-sdk
        uses: actions/cache/restore@v4
        with:
          path: ~/ncs/${{ env.NCS_VERSION }}
          key: ncs-sdk-${{ env.NCS_VERSION }}-v4

      - name: Install nRF Connect SDK Toolchain and SDK
        env:
          IMAGE_REF: ${{ steps.img.outputs.IMAGE_REF }}
        if: ${{ steps.cache-nrfutil-tcm.outputs.cache-hit != 'true' || steps.cache-ncs-toolchains.outputs.cache-hit != 'true' || steps.cache-ncs-sdk.outputs.cache-hit != 'true' }}
        run: |
          set -xeuo pipefail
          docker run --rm \
            --user "$(id -u)":"$(id -g)" \
            -e HOME=$HOME \
            -e USER="$(id -un)" \
            -e HOST_UID="$(id -u)" \
            -e HOST_GID="$(id -g)" \
            -e HOST_USER="$(id -un)" \
            -e HOST_GROUP="$(id -gn)" \
            -v "$HOME:$HOME" \
            -w $HOME \
            -e NCS_VERSION="${NCS_VERSION}" \
            "${IMAGE_REF}" \
            bash -lc '
              set -xeuo pipefail
              export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:-}"

              install_ncs_${NCS_VERSION}.sh
              source /usr/local/bin/dev-env-${NCS_VERSION}.sh

              which nrfutil
              nrfutil --version || true
              which west
              west --version || true
              which python3
              python3 --version || true
              which gcovr
              gcovr --version || true
              which yq
              yq --version || true
              which clang-format
              clang-format --version || true

              echo ">>> DONE"
            '
      - name: Save 'nrfutil Toolchain Manager'
        if: ${{ steps.cache-nrfutil-tcm.outputs.cache-hit != 'true' && !cancelled() }}
        uses: actions/cache/save@v4
        with:
          path: ~/.nrfutil
          key: ${{ steps.cache-nrfutil-tcm.outputs.cache-primary-key }}

      - name: Save 'nRF Connect toolchains' cache (only on miss)
        if: ${{ steps.cache-ncs-toolchains.outputs.cache-hit != 'true' && !cancelled() }}
        uses: actions/cache/save@v4
        with:
          path: ~/ncs/toolchains
          key: ${{ steps.cache-ncs-toolchains.outputs.cache-primary-key }}

      - name: Save 'nRF Connect SDK' cache (only on miss)
        if: ${{ steps.cache-ncs-sdk.outputs.cache-hit != 'true' && !cancelled() }}
        uses: actions/cache/save@v4
        with:
          path: ~/ncs/${{ env.NCS_VERSION }}
          key: ${{ steps.cache-ncs-sdk.outputs.cache-primary-key }}

      - name: Checkout the code
        uses: actions/checkout@v4
        with:
          path: ${{ env.PROJECT_DIR }}
          fetch-depth: 0
          submodules: true

      - name: Verify tag is on master (for release)
        id: master_check
        if: startsWith(github.ref, 'refs/tags/')
        shell: bash
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          git fetch --no-tags origin master
          if git merge-base --is-ancestor HEAD origin/master; then
            echo "tag_on_master=true" >> "$GITHUB_OUTPUT"
          else
            echo "tag_on_master=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare signing keys (host side; will be mounted read-only)
        env:
          B0_SIGN_KEY_PRIVATE: ${{ secrets.B0_SIGN_KEY_PRIVATE }}
          B0_PROD_SIGN_KEY_PUBLIC: ${{ secrets.B0_PROD_SIGN_KEY_PUBLIC }}
          IMAGE_SIGN: ${{ secrets.IMAGE_SIGN }}
        run: |
          set +x # do not echo secrets
          mkdir -p "$RUNNER_TEMP/signing_keys"
          install -m 600 /dev/null "$RUNNER_TEMP/signing_keys/b0_sign_key_private-dev.pem"
          install -m 600 /dev/null "$RUNNER_TEMP/signing_keys/b0_sign_key_public-prod.pem"
          install -m 600 /dev/null "$RUNNER_TEMP/signing_keys/image_sign-dev.pem"
          printf "%s" "$B0_SIGN_KEY_PRIVATE"     > "$RUNNER_TEMP/signing_keys/b0_sign_key_private-dev.pem"
          printf "%s" "$B0_PROD_SIGN_KEY_PUBLIC" > "$RUNNER_TEMP/signing_keys/b0_sign_key_public-prod.pem"
          printf "%s" "$IMAGE_SIGN"              > "$RUNNER_TEMP/signing_keys/image_sign-dev.pem"

      - name: Prepare derived env
        run: |
          echo "SCRIPT_PATH=./${SCRIPT_NAME}.sh" >> "$GITHUB_ENV"
          echo "BUILD_DIR_NAME=${SCRIPT_NAME}" >> "$GITHUB_ENV"

      - name: Download B0, mcuboot, and fwloader releases
        run: |
          cd "$GITHUB_WORKSPACE/${PROJECT_DIR}"
          "./${SCRIPT_PATH}" --download_releases

      - name: Build inside Docker container (reusing cached .nrfutil and ncs)
        env:
          IMAGE_REF: ${{ steps.img.outputs.IMAGE_REF }}
        run: |
          set -xeuo pipefail

          mv "$GITHUB_WORKSPACE/${PROJECT_DIR}" "$HOME/ncs/${{ env.NCS_VERSION }}/${{ env.PROJECT_DIR }}"

          docker run --rm \
            --network none \
            --cap-drop NET_ADMIN \
            --cap-drop NET_RAW \
            --cap-drop NET_BIND_SERVICE \
            --user "$(id -u)":"$(id -g)" \
            -e HOME=$HOME \
            -e USER="$(id -un)" \
            -e HOST_UID="$(id -u)" \
            -e HOST_GID="$(id -g)" \
            -e HOST_USER="$(id -un)" \
            -e HOST_GROUP="$(id -gn)" \
            -v "$HOME:$HOME" \
            -v "$RUNNER_TEMP/signing_keys:$HOME/.signing_keys:ro" \
            -w $HOME \
            -e NCS_VERSION="${NCS_VERSION}" \
            -e PROJECT_DIR="${PROJECT_DIR}" \
            -e SCRIPT_PATH="${SCRIPT_PATH}" \
            -e BUILD_DIR_NAME="${BUILD_DIR_NAME}" \
            "${IMAGE_REF}" \
            bash -lc '
              set -xeuo pipefail

              export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:-}"

              echo ">>> Init dev env"
              source /usr/local/bin/dev-env-${NCS_VERSION}.sh

              cd $HOME/ncs/${NCS_VERSION}/${PROJECT_DIR}

              echo ">>> Running build script: ${SCRIPT_PATH}"
              "./${SCRIPT_PATH}" --build_dir="${BUILD_DIR_NAME}"
            '

          mv "$HOME/ncs/${{ env.NCS_VERSION }}/${{ env.PROJECT_DIR }}" "$GITHUB_WORKSPACE/${PROJECT_DIR}"

      - name: Cleanup signing keys
        if: always()
        run: |
          rm -rf "$RUNNER_TEMP/signing_keys"

      - name: Create zip
        id: create_zip
        env:
          TAG: ${{ github.ref_name }}
          TAG_ON_MASTER: ${{ steps.master_check.outputs.tag_on_master }}
        shell: bash
        run: |
          set -xeuo pipefail
          pwd
          if [[ "${TAG_ON_MASTER:-false}" == "true" ]]; then
            ARTIFACT_NAME="${{ env.BUILD_DIR_NAME }}_${TAG}"
          else
            ARTIFACT_NAME="${{ env.BUILD_DIR_NAME }}"
          fi

          # Create directory "$ARTIFACT_NAME" for artifacts and copy files there

          SRC="${{ env.PROJECT_DIR }}/${{ env.BUILD_DIR_NAME }}"
          DST="$ARTIFACT_NAME/${{ env.BUILD_DIR_NAME }}"

          paths=(
            "merged.hex"
            "merged.ext_flash.hex"
            "b0_container.hex"
            "app_provision.hex"
            "signed_by_mcuboot_and_b0_mcuboot.bin"
            "signed_by_mcuboot_and_b0_mcuboot.hex"
            "signed_by_mcuboot_and_b0_s1_image.bin"
            "signed_by_mcuboot_and_b0_s1_image.hex"
            "firmware_loader/zephyr/ruuvi_air_fw_loader.signed.bin"
            "firmware_loader/zephyr/ruuvi_air_fw_loader.signed.hex"
            "${{ env.PROJECT_DIR }}/zephyr/ruuvi_air_fw.signed.bin"
            "${{ env.PROJECT_DIR }}/zephyr/ruuvi_air_fw.signed.hex"
          )

          for rel in "${paths[@]}"; do
            src_path="$SRC/$rel"
            dst_path="$DST/$rel"
            mkdir -p "$(dirname "$dst_path")"
            cp "$src_path" "$dst_path"
          done
          cp ${{ env.PROJECT_DIR }}/nrfjprog_cfg_ruuviair.toml "$ARTIFACT_NAME/nrfjprog_cfg_ruuviair.toml"

          # Create zip file to upload as release asset
          ARTIFACT_PATH="$GITHUB_WORKSPACE/$ARTIFACT_NAME.zip"
          zip -r -q "$ARTIFACT_PATH" "$ARTIFACT_NAME"

          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"
          echo "artifact_path=$ARTIFACT_PATH" >> "$GITHUB_OUTPUT"

      - name: Create release and upload asset
        if: startsWith(github.ref, 'refs/tags/') && steps.master_check.outputs.tag_on_master == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ github.ref_name }}
          ARTIFACT_PATH: ${{ steps.create_zip.outputs.artifact_path }}
        shell: bash
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          set -xe
          command -v gh >/dev/null 2>&1 || { echo "gh CLI not found"; exit 1; }
          # create if missing; on failure re-check to tolerate races
          if ! gh release view "$TAG" >/dev/null 2>&1; then
            if ! gh release create "$TAG" --title "$TAG" --notes "Automated release" --prerelease; then
              echo "Create failed; rechecking..."
              if ! gh release view "$TAG" >/dev/null 2>&1; then
                echo "Release still missing; aborting."
                exit 1
              fi
            fi
          fi
          gh release upload "$TAG" "$ARTIFACT_PATH" --clobber

      - name: Upload artifact ${{ steps.create_zip.outputs.artifact_name }}
        uses: actions/upload-artifact@v4
        with:
          # Use a name without .zip; GitHub adds .zip on download if the name ends with .zip
          name: ${{ steps.create_zip.outputs.artifact_name }}
          # Upload whole directory with build artifacts
          path: ${{ steps.create_zip.outputs.artifact_path }}
