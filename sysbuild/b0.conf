#
# @copyright Ruuvi Innovations Ltd
#
# SPDX-License-Identifier: BSD-3-Clause
#
CONFIG_KERNEL_BIN_NAME="ruuvi_air_b0"

CONFIG_DISABLE_FLASH_PATCH=y

CONFIG_HEAP_MEM_POOL_SIZE=0

# By default, libc heap uses all free memory,
# but we reserved some SRAM for shared data between B0 and MCUboot,
# and libc does not know about it - it uses global memory allocation rules from Partition Manager.
# As a workaround, we set the heap size explicitly, so that an array will be allocated for the heap
# and the linker will fail if the heap size is too big and overlaps with the shared area "SharedMemB0_MCUboot".
# For the B0 bootloader, we set the heap size to minimal value of 256 bytes,
# because the B0 bootloader uses only few dynamic memory allocation.
# And we need to reserve as little memory as possible because all unused memory is powered down in low power mode.
CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=256

CONFIG_MAIN_STACK_SIZE=4096

CONFIG_SIZE_OPTIMIZATIONS=y

CONFIG_FLASH=y
CONFIG_FLASH_MAP=y

CONFIG_SYS_CLOCK_EXISTS=y
CONFIG_TICKLESS_KERNEL=y

CONFIG_GPIO=y
CONFIG_NRFX_TIMER4=y
CONFIG_NRFX_GPIOTE0=y
CONFIG_NRFX_PPI=y

CONFIG_RETAINED_MEM=y
CONFIG_RETENTION=y
CONFIG_RETENTION_BOOT_MODE=y

CONFIG_SOC_LATE_INIT_HOOK=y

CONFIG_SECURE_BOOT_STORAGE=y
CONFIG_SECURE_BOOT_VALIDATION=y
CONFIG_SB_CRYPTO_OBERON_ECDSA_SECP256R1=y
# Use software implementation of SHA256
# Hardware implementation in ~/ncs/<VERSION>/nrf/subsys/bootloader/bl_crypto/bl_crypto_cc310_hash.c
# creates 32KiB 'ram_buffer' in RAM.
# Using software implementation allows to increase the amout of available RAM.
# Also, that can be useful for RAM regions that can be powered down
# which will save power during low power mode.
CONFIG_SB_CRYPTO_OBERON_SHA256=y

CONFIG_REBOOT=y
CONFIG_POWEROFF=y

# --- Basic Logging Setup ---
CONFIG_LOG=y
CONFIG_LOG_MODE_MINIMAL=y
CONFIG_LOG_DEFAULT_LEVEL=3
CONFIG_LOG_MAX_LEVEL=3
# CONFIG_LOG_PRINTK=y     # It is not used when CONFIG_LOG_MODE_MINIMAL is active
# CONFIG_PRINTK=n

# --- Enable UART ---
CONFIG_SERIAL=y           # Ensure Serial driver support is enabled (usually default)
CONFIG_UART_CONSOLE=y     # Enable UART as a potential console (usually default)
CONFIG_LOG_BACKEND_UART=y # Enable UART as a logging backend

# --- Enable RTT ---
# When `CONFIG_LOG_MODE_MINIMAL=y`,
# then the logging system falls back to a simpler mechanism.
# When CONFIG_LOG_PRINTK=y is also enabled, calls to LOG_x() functions essentially become wrappers
# that directly call printk().
# The printk() function, by default, sends its output to the single active console.
# Even if you enable both CONFIG_UART_CONSOLE=y and CONFIG_RTT_CONSOLE=y,
# Zephyr usually selects only one as the active console (which is UART by default).
# So, to enable RTT you need to disable the UART console: `CONFIG_SERIAL=n`.
# But here a custom wrapper for 'vprintk' is used to send the log messages to both targets UART and RTT.
CONFIG_USE_SEGGER_RTT=y
CONFIG_RTT_CONSOLE=y      # Enable RTT as a potential console
CONFIG_LOG_BACKEND_RTT=y  # Enable RTT as a logging backend

# Configure Segger RTT UpBuffer, with 184 additional bytes for other RTT data, in total it's 4096
CONFIG_SEGGER_RTT_BUFFER_SIZE_UP=3912
CONFIG_SEGGER_RTT_SECTION_CUSTOM=y
CONFIG_SEGGER_RTT_SECTION_CUSTOM_NAME="rtt_data"

CONFIG_EXCEPTION_DEBUG=y
CONFIG_EXTRA_EXCEPTION_INFO=y
CONFIG_FAULT_DUMP=2

# Workaround for the warning: HW_STACK_PROTECTION (defined at soc/nxp/s32/s32k1/Kconfig.defconfig:20, arch/Kconfig:283) was assigned the value 'y' but got the value 'n'.
CONFIG_HW_STACK_PROTECTION=n

CONFIG_BL_SHA256_EXT_API_ENABLED=y
CONFIG_BL_SECP256R1_EXT_API_ENABLED=y
CONFIG_BL_ROT_VERIFY_EXT_API_ENABLED=y

CONFIG_GPIO_INIT_PRIORITY=40
CONFIG_NORDIC_QSPI_NOR_INIT_PRIORITY=45

# NCS boot banner
CONFIG_NCS_BOOT_BANNER=y

CONFIG_FW_INFO=y
